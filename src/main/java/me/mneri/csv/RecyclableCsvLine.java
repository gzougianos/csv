/*
 * This file is part of mneri/csv.
 *
 * mneri/csv is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * mneri/csv is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with mneri/csv. If not, see <http://www.gnu.org/licenses/>.
 */

package me.mneri.csv;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Arrays;

/**
 * A csv line which is generated by {@link CsvReader}. This class provides getter methods
 * ({@link RecyclableCsvLine#getBoolean}, {@link RecyclableCsvLine#getLong}, and so on) for retrieving column values.
 * Instances of this class shouldn't be used outside the scope of the method they're provided to because instances may
 * be cleaned and reused by {@link CsvReader}.
 *
 * @author Massimo Neri &lt;<a href="mailto:hello@mneri.me">hello@mneri.me</a>&gt;
 */
public final class RecyclableCsvLine {
    private static final int DEFAULT_BUFFER_SIZE = 1024;

    private char[] chars;
    private int[] ends;
    private int fieldCount;
    private int nextChar;
    private int nextEnd;

    RecyclableCsvLine() {
        chars = new char[DEFAULT_BUFFER_SIZE];
        ends = new int[DEFAULT_BUFFER_SIZE];
    }

    private void checkField(int i) {
        if (i >= fieldCount) {
            throw new ArrayIndexOutOfBoundsException(i);
        }
    }

    void clear() {
        fieldCount = nextChar = nextEnd = 0;
    }

    private void ensureCapacity(int minimumCapacity) {
        int oldCapacity = chars.length;

        if (minimumCapacity - oldCapacity <= 0) {
            return;
        }

        int newCapacity = oldCapacity * 2 + 2;

        if (newCapacity < 0) {
            newCapacity = Integer.MAX_VALUE;
        }

        chars = Arrays.copyOf(chars, newCapacity);
        ends = Arrays.copyOf(ends, newCapacity);
    }

    /**
     * Return the value of the field at the specified index as {@link BigDecimal}.
     *
     * @param i The index of the field.
     * @return The value of the field.
     */
    public BigDecimal getBigDecimal(int i) {
        checkField(i);

        int length = getFieldLength(i);

        if (length == 0) {
            return null;
        }

        return new BigDecimal(chars, getFieldStart(i), length);
    }

    public BigInteger getBigInteger(int i) {
        throw new UnsupportedOperationException("Not yet implemented.");
    }

    /**
     * Return the value of the field at the specified index as {@link Boolean}.
     *
     * @param i The index of the field.
     * @return The value of the field.
     */
    public Boolean getBoolean(int i) {
        throw new UnsupportedOperationException("Not yet implemented.");
    }

    /**
     * Return the value of the field at the specified index as {@link Double}.
     *
     * @param i The index of the field.
     * @return The value of the field.
     */
    public Double getDouble(int i) {
        return getDouble(i, 10);
    }

    /**
     * Return the value of the field at the specified index as {@link Double} in the radix specified by the second
     * argument. The characters in the string must all be digits of the specified radix, except that the first character
     * may be an ASCII minus sign {@code '-'} an ASCII plus sign {@code '+'}.
     *
     * @param i     The index of the field.
     * @param radix The radix to be used.
     * @return The value of the field.
     */
    public Double getDouble(int i, int radix) {
        throw new UnsupportedOperationException("Not yet implemented.");
    }

    /**
     * Return the number of fields in this line.
     *
     * @return The number of fields.
     */
    public int getFieldCount() {
        return fieldCount;
    }

    private int getFieldLength(int i) {
        return i == 0 ? ends[0] : ends[i] - ends[i - 1];
    }

    private int getFieldStart(int i) {
        return i == 0 ? 0 : ends[i - 1];
    }

    /**
     * Return the value of the field at the specified index as {@link Float}.
     *
     * @param i The index of the field.
     * @return The value of the field.
     */
    public Float getFloat(int i) {
        return getFloat(i, 10);
    }

    /**
     * Return the value of the field at the specified index as {@link Float} in the radix specified by the second
     * argument. The characters in the string must all be digits of the specified radix, except that the first character
     * may be an ASCII minus sign {@code '-'} an ASCII plus sign {@code '+'}.
     *
     * @param i     The index of the field.
     * @param radix The radix to be used.
     * @return The value of the field.
     */
    public Float getFloat(int i, int radix) {
        throw new UnsupportedOperationException("Not yet implemented.");
    }

    /**
     * Return the value of the field at the specified index as {@link Integer}.
     *
     * @param i The index of the field.
     * @return The value of the field.
     */
    public Integer getInteger(int i) {
        return getInteger(i, 10);
    }

    /**
     * Return the value of the field at the specified index as {@link Integer} in the radix specified by the second
     * argument. The characters in the string must all be digits of the specified radix, except that the first character
     * may be an ASCII minus sign {@code '-'} an ASCII plus sign {@code '+'}.
     *
     * @param i     The index of the field.
     * @param radix The radix to be used.
     * @return The value of the field.
     */
    public Integer getInteger(int i, int radix) {
        throw new UnsupportedOperationException("Not yet implemented.");
    }

    /**
     * Return the value of the field at the specified index as {@link Long}.
     *
     * @param i The index of the field.
     * @return The value of the field.
     */
    public Long getLong(int i) {
        return getLong(i, 10);
    }

    /**
     * Return the value of the field at the specified index as {@link Long} in the radix specified by the second
     * argument. The characters in the string must all be digits of the specified radix, except that the first character
     * may be an ASCII minus sign {@code '-'} an ASCII plus sign {@code '+'}.
     *
     * @param i     The index of the field.
     * @param radix The radix to be used.
     * @return The value of the field.
     */
    public Long getLong(int i, int radix) {
        throw new UnsupportedOperationException("Not yet implemented.");
    }

    /**
     * Return the value of the field at the specified index as {@link Short}.
     *
     * @param i The index of the field.
     * @return The value of the field.
     */
    public Short getShort(int i) {
        throw new UnsupportedOperationException("Not yet implemented.");
    }

    /**
     * Return the value of the field at the specified index as {@link Short} in the radix specified by the second
     * argument. The characters in the string must all be digits of the specified radix, except that the first character
     * may be an ASCII minus sign {@code '-'} an ASCII plus sign {@code '+'}.
     *
     * @param i     The index of the field.
     * @param radix The radix to be used.
     * @return The value of the field.
     */
    public Short getShort(int i, int radix) {
        throw new UnsupportedOperationException("Not yet implemented.");
    }

    /**
     * Return the value of the field at the specified index as {@link String}.
     *
     * @param i The index of the field.
     * @return The value of the field.
     */
    public String getString(int i) {
        checkField(i);

        int length = getFieldLength(i);

        if (length == 0) {
            return null;
        }

        return new String(chars, getFieldStart(i), length);
    }

    void markField() {
        ends[nextEnd++] = nextChar;
        fieldCount++;
    }

    void put(int codePoint) {
        ensureCapacity(nextChar + 2);
        nextChar += Character.toChars(codePoint, chars, nextChar);
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        int count = getFieldCount();

        for (int i = 0; i < count; i++) {
            builder.append(getString(i));
            builder.append(i < count - 1 ? "," : "");
        }

        return builder.toString();
    }
}
